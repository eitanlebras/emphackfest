{% extends "base.html" %}

{% block title %}Results — SalmonShield{% endblock %}

{% block content %}

    <!-- score panel -->
    <div class="results-panel">
        {% if nearest_stream_dist_km %}
            <h2>Danger Score: N/A</h2>
            <p>Move closer to a salmon stream to see your impact score.</p>
        {% else %}
            <h2>Danger Score: {{ impact_score }}/100</h2>
            <p>Risk Level: <span class="risk-badge risk-{{ risk_color }}">{{ risk_color | upper }}</span></p>
        {% endif %}
    </div>

    <!-- alert when no rivers are nearby -->
    {% if nearest_stream_dist_km %}
    <div class="no-rivers-alert">
        No salmon streams within 1 km. Nearest stream is <strong>{{ nearest_stream_dist_km }} km</strong> away (shown on map).
    </div>
    {% endif %}

    <!-- leaflet map fills this div -->
    <div id="results-map"></div>

    <!-- styles for map popups, legend, layer panel, and suggestions -->
    <style>
        /* popup card that appears when clicking a stream/point */
        .popup-card { font-family: 'Lato', sans-serif; min-width: 200px; }
        .popup-card h3 { margin: 0 0 6px; font-size: 14px; }
        .popup-card p { margin: 2px 0; font-size: 12px; color: #444; }
        .popup-card .risk-badge { padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; color: #fff; }
        .popup-card .risk-red { background: #e63946; }     /* high risk */
        .popup-card .risk-yellow { background: #fb8500; color: #1b1b1b; } /* moderate */
        .popup-card .risk-green { background: #2a9d8f; }   /* low risk */
        .popup-card .divider { border-top: 1px solid #eee; margin: 6px 0; }

        /* legend box (top-right of map) */
        .map-legend { background: #fff; padding: 10px 14px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-family: 'Lato', sans-serif; font-size: 12px; line-height: 1.8; }
        .map-legend h4 { margin: 0 0 6px; font-size: 13px; }
        .map-legend i { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
        .map-legend .line { width: 18px; height: 4px; border-radius: 2px; display: inline-block; margin-right: 6px; vertical-align: middle; }

        /* layer toggle panel (top-left of map) */
        .layer-panel { background: #fff; padding: 10px 14px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-family: 'Lato', sans-serif; font-size: 12px; line-height: 2; }
        .layer-panel h4 { margin: 0 0 4px; font-size: 13px; }
        .layer-panel label { display: block; cursor: pointer; }
        .layer-panel input[type="checkbox"] { margin-right: 6px; vertical-align: middle; }

        /* GPT suggestions section below the map */
        .suggestions-card { padding: 16px 0; margin: 20px 0; }
        .suggestions-card h3 { margin: 0 0 12px; font-size: 16px; }
        .suggestions-card .suggestion { margin-bottom: 16px; }
        .suggestions-card .suggestion:last-child { margin-bottom: 0; }
        .suggestions-card h4 { margin: 0 0 6px; font-size: 14px; }
        .suggestions-card p { margin: 0; font-size: 13px; color: #444; line-height: 1.7; white-space: pre-line; }

        /* color bar showing impervious surface gradient in legend */
        .nlcd-gradient { width: 100px; height: 10px; border-radius: 3px; display: inline-block; vertical-align: middle; margin-right: 6px;
            background: linear-gradient(to right, rgba(0,200,30,0.4), rgba(200,100,30,0.7), rgba(255,0,30,0.9)); }
    </style>

    <script>
        // --- data injected from Flask backend (Jinja2 fills these in) ---
        var streams = {{ streams_json | safe }};            // nearby salmon stream features
        var stormwater = {{ stormwater_json | safe }};      // nearby stormwater discharge points
        var watershedFeatures = {{ watersheds_json | safe }};// watershed boundary polygons
        var waterQuality = {{ water_quality_json | default('null') | safe }};  // water quality data or null
        var trafficData = {{ traffic_json | default('null') | safe }};         // traffic exposure or null
        var userLat = {{ lat }};    // user's latitude
        var userLon = {{ lon }};    // user's longitude
        var drainCount = stormwater.length;  // total discharge points within 1km

        // color and label mappings for risk levels
        var riskColors = { red: "#e63946", yellow: "#fb8500", green: "#2a9d8f" };
        var riskLabels = { red: "High", yellow: "Moderate", green: "Low" };

        // haversine formula: distance in meters between two lat/lon points
        function distanceMeters(lat1, lon1, lat2, lon2) {
            var R = 6371000;
            var dLat = (lat2 - lat1) * Math.PI / 180;
            var dLon = (lon2 - lon1) * Math.PI / 180;
            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        // create the map centered on the user's location
        var map = L.map('results-map').setView([userLat, userLon], 14);

        // add the base tile layer (OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // --- watershed boundary polygons (togglable via checkbox) ---
        var wsPalette = ["#264653","#2a9d8f","#e9c46a","#f4a261","#e76f51","#6a4c93","#1982c4","#8ac926"];
        var watershedGroup = L.layerGroup(); // container for all watershed layers
        watershedFeatures.forEach(function(feature, i) {
            var color = wsPalette[i % wsPalette.length]; // cycle through colors
            var name = feature.properties.Name || "Unknown";
            var area = feature.properties.AreaSqKm ? parseFloat(feature.properties.AreaSqKm).toFixed(1) + " km²" : "N/A";
            var huc = feature.properties.HUC12 || "";

            // draw the watershed polygon with dashed border
            var layer = L.geoJSON(feature, {
                style: { color: color, weight: 2, fillColor: color, fillOpacity: 0.15, dashArray: "6 4" }
            });
            layer.bindPopup(
                '<div class="popup-card">' +
                '  <h3>' + name + ' Watershed</h3>' +
                '  <p>HUC-12: <strong>' + huc + '</strong></p>' +
                '  <p>Area: <strong>' + area + '</strong></p>' +
                '</div>'
            );
            // highlight on hover
            layer.on("mouseover", function() { layer.setStyle({ fillOpacity: 0.3, weight: 3 }); });
            layer.on("mouseout", function() { layer.setStyle({ fillOpacity: 0.15, weight: 2 }); });
            watershedGroup.addLayer(layer); // add to the togglable group
        });

        // --- NLCD impervious surface overlay (togglable) ---
        var nlcdOverlay = null; // current image overlay on the map

        // request a new NLCD PNG from the server for current map bounds
        function loadNlcdOverlay() {
            var b = map.getBounds();
            var size = map.getSize();
            var url = "/nlcd_tile?west=" + b.getWest() + "&south=" + b.getSouth() +
                      "&east=" + b.getEast() + "&north=" + b.getNorth() +
                      "&width=" + size.x + "&height=" + size.y;
            if (nlcdOverlay) map.removeLayer(nlcdOverlay); // remove stale overlay
            nlcdOverlay = L.imageOverlay(url, b, { opacity: 0.7, interactive: false });
            nlcdOverlay.addTo(map);
        }

        var nlcdEnabled = false; // whether the NLCD checkbox is on

        // refresh NLCD overlay when user pans/zooms the map
        map.on("moveend", function() {
            if (nlcdEnabled) loadNlcdOverlay();
        });

        // mark the user's location
        L.marker([userLat, userLon]).addTo(map)
            .bindPopup("Your location").openPopup();

        // --- checkbox panel to toggle optional layers ---
        var filterPanel = L.control({ position: "topleft" });
        filterPanel.onAdd = function() {
            var div = L.DomUtil.create("div", "layer-panel");
            div.innerHTML =
                '<h4>Layers</h4>' +
                '<label><input type="checkbox" id="toggle-watersheds"> Watershed Boundaries</label>' +
                '<label><input type="checkbox" id="toggle-nlcd"> Impervious Surface (NLCD)</label>';
            L.DomEvent.disableClickPropagation(div); // prevent map clicks when clicking panel
            return div;
        };
        filterPanel.addTo(map);

        // toggle watershed polygons on/off
        document.getElementById("toggle-watersheds").addEventListener("change", function() {
            if (this.checked) map.addLayer(watershedGroup);
            else map.removeLayer(watershedGroup);
            rebuildLegend(); // update legend to show/hide watershed entries
        });

        // toggle NLCD impervious overlay on/off
        document.getElementById("toggle-nlcd").addEventListener("change", function() {
            nlcdEnabled = this.checked;
            if (nlcdEnabled) loadNlcdOverlay();
            else if (nlcdOverlay) { map.removeLayer(nlcdOverlay); nlcdOverlay = null; }
            rebuildLegend(); // update legend to show/hide gradient bar
        });

        // these hold async-fetched values so they survive legend rebuilds
        var roadDensityHtml = '<em>loading\u2026</em>';
        var weatherHtml = '<em>loading\u2026</em>';

        // --- legend control (top-right) — rebuilt whenever a layer toggles ---
        var legendDiv = null;
        var legendControl = L.control({ position: "topright" });
        legendControl.onAdd = function() {
            legendDiv = L.DomUtil.create("div", "map-legend");
            rebuildLegend();
            return legendDiv;
        };
        legendControl.addTo(map);

        // rebuild the entire legend HTML (called on toggle and async data arrival)
        function rebuildLegend() {
            if (!legendDiv) return;
            var html =
                '<h4>Legend</h4>' +
                '<i style="background:#7b2cbf"></i> Stormwater Discharge Point<br>' +
                '<span class="line" style="background:#e63946"></span> High Risk Stream<br>' +
                '<span class="line" style="background:#fb8500"></span> Moderate Risk Stream<br>' +
                '<span class="line" style="background:#2a9d8f"></span> Low Risk Stream';

            // show watershed colors only when that layer is enabled
            if (document.getElementById("toggle-watersheds") && document.getElementById("toggle-watersheds").checked) {
                html += '<br><strong style="font-size:11px;margin-top:4px;display:inline-block;">Watersheds</strong>';
                watershedFeatures.forEach(function(f, i) {
                    var c = wsPalette[i % wsPalette.length];
                    var n = f.properties.Name || "Watershed " + (i+1);
                    html += '<br><i style="background:' + c + ';opacity:0.5"></i> ' + n;
                });
            }

            // show impervious surface gradient only when that layer is enabled
            if (document.getElementById("toggle-nlcd") && document.getElementById("toggle-nlcd").checked) {
                html += '<br><strong style="font-size:11px;margin-top:4px;display:inline-block;">Impervious Surface</strong>';
                html += '<br><span class="nlcd-gradient"></span> 0 – 100%';
            }

            // water quality: color-coded by rank (1-10 scale)
            if (waterQuality) {
                var wqRank = waterQuality.max_rank;
                var wqColor = wqRank <= 4 ? '#2a9d8f' : wqRank <= 7 ? '#fb8500' : '#e63946';
                var wqLabel = wqRank <= 4 ? 'Low' : wqRank <= 7 ? 'Moderate' : 'High';
                html += '<br><hr style="margin:6px 0;border:none;border-top:1px solid #eee;">' +
                        '<span style="font-size:11px;color:#555;">Water quality (local):<br>' +
                        '<strong style="color:' + wqColor + '">' + wqLabel + '</strong>' +
                        ' &mdash; ' + waterQuality.total_impairments + ' impairment' +
                        (waterQuality.total_impairments !== 1 ? 's' : '') + ' detected</span>';
            }

            // traffic exposure: color-coded by Environmental Health Disparities rank
            if (trafficData) {
                var tRank = trafficData.ehd_rank;
                var tColor = tRank <= 4 ? '#2a9d8f' : tRank <= 7 ? '#fb8500' : '#e63946';
                var tLabel = tRank <= 4 ? 'Low' : tRank <= 7 ? 'Moderate' : 'High';
                html += '<br><hr style="margin:6px 0;border:none;border-top:1px solid #eee;">' +
                        '<span style="font-size:11px;color:#555;">Heavy traffic exposure:<br>' +
                        '<strong style="color:' + tColor + '">' + tLabel + '</strong>' +
                        ' &mdash; EHD rank ' + tRank + '/10</span>';
            }

            // road density (value persists across rebuilds)
            html += '<br><hr style="margin:6px 0;border:none;border-top:1px solid #eee;">' +
                    '<span style="font-size:11px;color:#555;">Road density (500m): ' + roadDensityHtml + '</span>';

            // weather forecast (value persists across rebuilds)
            html += '<br><hr style="margin:6px 0;border:none;border-top:1px solid #eee;">' +
                    '<span style="font-size:11px;color:#555;">Precipitation forecast:<br>' + weatherHtml + '</span>';

            legendDiv.innerHTML = html;
        }

        // --- road density from OpenStreetMap (Overpass API, 500m radius) ---
        (function() {
            var RADIUS = 500; // meters
            var AREA_KM2 = Math.PI * (RADIUS / 1000) * (RADIUS / 1000); // circle area
            // query all roads within 500m of user
            var query = '[out:json][timeout:15];(way["highway"](around:' + RADIUS + ',' +
                        userLat + ',' + userLon + '););out geom;';
            fetch('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'data=' + encodeURIComponent(query)
            })
            .then(function(r) { return r.json(); })
            .then(function(data) {
                var totalM = 0; // total road length in meters
                var elements = data.elements || [];
                // sum up the length of each road segment
                elements.forEach(function(way) {
                    if (!way.geometry || way.geometry.length < 2) return;
                    for (var i = 0; i < way.geometry.length - 1; i++) {
                        totalM += distanceMeters(
                            way.geometry[i].lat, way.geometry[i].lon,
                            way.geometry[i+1].lat, way.geometry[i+1].lon
                        );
                    }
                });
                if (elements.length === 0) {
                    roadDensityHtml = 'unavailable'; // no OSM data here
                } else {
                    var density = (totalM / 1000) / AREA_KM2; // km of road per km²
                    var label, color;
                    if (density < 5)       { label = 'Low';      color = '#2a9d8f'; }
                    else if (density < 15) { label = 'Moderate'; color = '#fb8500'; }
                    else                   { label = 'High';     color = '#e63946'; }
                    roadDensityHtml = '<strong style="color:' + color + '">' + label + '</strong>' +
                                      ' \u2014 ' + density.toFixed(1) + ' km/km\u00B2';
                }
                rebuildLegend(); // update legend with the result
            })
            .catch(function() {
                roadDensityHtml = 'unavailable';
                rebuildLegend();
            });
        })();

        // --- 3-day precipitation forecast from Open-Meteo (free, no API key) ---
        (function() {
            var url = 'https://api.open-meteo.com/v1/forecast' +
                      '?latitude=' + userLat + '&longitude=' + userLon +
                      '&daily=precipitation_sum,precipitation_probability_max' +
                      '&precipitation_unit=inch&timezone=auto&forecast_days=3';
            fetch(url)
            .then(function(r) { return r.json(); })
            .then(function(data) {
                var days  = data.daily.time;            // ["2026-02-22", ...]
                var precip = data.daily.precipitation_sum;  // inches per day
                var prob   = data.daily.precipitation_probability_max; // % chance
                var dayNames = ['Today', 'Tomorrow', days[2] ? days[2].slice(5) : 'Day 3'];
                var rows = '';
                for (var i = 0; i < 3; i++) {
                    var p = (precip[i] || 0).toFixed(2);
                    var pct = prob[i] != null ? prob[i] : '–';
                    rows += dayNames[i] + ': <strong>' + pct + '% chance</strong>, ' + p + ' in<br>';
                }
                weatherHtml = rows;
                rebuildLegend(); // update legend with forecast
            })
            .catch(function() {
                weatherHtml = 'unavailable';
                rebuildLegend();
            });
        })();

        // species list shown in every stream popup
        var salmonSpecies = "Chinook Salmon, Coho Salmon, Chum Salmon, Pink Salmon, Sockeye Salmon";

        // --- draw each salmon stream on the map ---
        streams.forEach(function(feature) {
            var risk = feature.properties.riskColor || "green";
            var color = riskColors[risk] || "#2a9d8f";
            var name = feature.properties.LLID_STRM_NAME || "Salmon stream";

            // find the closest point on this stream to the user
            var coords = feature.geometry.coordinates;
            var dist = Infinity;
            for (var ci = 0; ci < coords.length; ci++) {
                var d = distanceMeters(userLat, userLon, coords[ci][1], coords[ci][0]);
                if (d < dist) dist = d; // keep the minimum
            }
            dist = Math.round(dist);

            // popup content shown on click
            var popup =
                '<div class="popup-card">' +
                '  <h3>' + name + '</h3>' +
                '  <p>Species: <strong>' + salmonSpecies + '</strong></p>' +
                '  <p>Risk: <span class="risk-badge risk-' + risk + '">' + riskLabels[risk] + '</span></p>' +
                '  <div class="divider"></div>' +
                '  <p>Distance: <strong>' + dist + ' m</strong> from your location</p>' +
                '  <p style="font-size:11px;color:#888;">Watershed: ' + (feature.properties.watershed_name || "Unknown") + '</p>' +
                '</div>';

            // draw the stream line on the map
            var layer = L.geoJSON(feature, {
                style: { color: color, weight: 5, opacity: 0.9 }
            }).addTo(map);
            layer.bindPopup(popup);

            // thicken line on hover for visibility
            layer.on("mouseover", function(e) {
                layer.setStyle({ weight: 8, opacity: 1 });
                e.target._path && (e.target._path.style.cursor = "pointer");
            });
            // mouseout: reset
            layer.on("mouseout", function() {
                layer.setStyle({ weight: 5, color: color, opacity: 0.9 });
            });
        });

        // --- draw stormwater discharge points as purple circles ---
        stormwater.forEach(function(feature) {
            var coords = feature.geometry && feature.geometry.coordinates;
            if (!coords) return; // skip if no geometry

            var dist = Math.round(distanceMeters(userLat, userLon, coords[1], coords[0]));
            var dname = feature.properties.DischargeName || "Unnamed";

            // explain how many drains contribute to the score
            var contribution = drainCount + " discharge point" + (drainCount !== 1 ? "s" : "") +
                " within 1 km — adds up to " + Math.min(30, drainCount * 5) + " pts to the impact score.";

            var popup =
                '<div class="popup-card">' +
                '  <h3>Stormwater Discharge Point</h3>' +
                '  <p>ID: <strong>' + dname + '</strong></p>' +
                '  <div class="divider"></div>' +
                '  <p>Distance: <strong>' + dist + ' m</strong> from your location</p>' +
                '  <p style="font-size:11px;color:#888;">' + contribution + '</p>' +
                '</div>';

            var marker = L.circleMarker([coords[1], coords[0]], {
                radius: 8,
                color: "#7b2cbf",
                fillColor: "#7b2cbf",
                fillOpacity: 0.85,
                weight: 2
            }).addTo(map).bindPopup(popup);

            // hover: grow and highlight
            marker.on("mouseover", function() {
                marker.setRadius(12);
                marker.setStyle({ weight: 3, color: "#fff" });
                marker._path && (marker._path.style.cursor = "pointer");
            });
            // mouseout: shrink back
            marker.on("mouseout", function() {
                marker.setRadius(8);
                marker.setStyle({ weight: 2, color: "#7b2cbf" });
            });
        });

        // --- fallback: draw nearest stream if none within 1km ---
        var nearestPoint = {{ nearest_stream_point | safe }};           // [lat, lon] or null
        var nearestStreamFeature = {{ nearest_stream_feature_json | default('null') | safe }};
        if (nearestPoint) {
            // dashed red line from user to the closest point on the stream
            L.polyline([[userLat, userLon], nearestPoint], {
                color: "#e63946", weight: 3, dashArray: "10, 8", opacity: 0.8
            }).addTo(map);

            // draw the full stream geometry so user can see it
            if (nearestStreamFeature) {
                var risk = nearestStreamFeature.properties.riskColor || "red";
                var sColor = riskColors[risk] || "#e63946";
                var sName = nearestStreamFeature.properties.LLID_STRM_NAME || "Nearest stream";
                L.geoJSON(nearestStreamFeature, {
                    style: { color: sColor, weight: 5, opacity: 0.9 }
                }).addTo(map).bindPopup(
                    '<div class="popup-card"><h3>' + sName + '</h3>' +
                    '<p>Risk: <span class="risk-badge risk-' + risk + '">' + (riskLabels[risk] || "High") + '</span></p>' +
                    '<p style="font-size:11px;color:#888;">Watershed: ' + (nearestStreamFeature.properties.watershed_name || "Unknown") + '</p></div>'
                );
            }

            // auto-zoom to fit both user location and nearest stream
            map.fitBounds([
                [userLat, userLon], nearestPoint
            ], { padding: [50, 50] });
        }
    </script>

    <!-- address search bar (uses Google Places autocomplete) -->
    <div class="enter-location">
            <label for="pac-container" id="address-label">Type your address</label>
            <div id="pac-container"></div>
            <p class="discalimer">We don't store your data. <a href="#">Privacy Policy</a></p>
    </div>

    <script src="{{ url_for('static', filename='js/index.js') }}"></script>
    <!-- Google Maps JS for address autocomplete -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA8AfiCIiL8W1Q6CNiTGfFVxur20jb3eP8&callback=initMap&libraries=places&v=weekly" defer></script>

    <!-- AI-generated suggestions for this location -->
    {% if suggestions %}
    <div class="suggestions-card">
        <h3>What You Can Do Here</h3>
        {% if suggestions.community %}
        <div class="suggestion">
            <h4>For Community Members</h4>
            <p>{{ suggestions.community }}</p>
        </div>
        {% endif %}
        {% if suggestions.scientist %}
        <div class="suggestion">
            <h4>For Conservation Scientists</h4>
            <p>{{ suggestions.scientist }}</p>
        </div>
        {% endif %}
    </div>
    {% endif %}

        <!-- FAQ section -->
        <div>
        <h3>How do we calculate the danger score?</h3>
        <p>Our danger score is calculated based on a the weighted sum of several factors including proximity to heavy traffic roadways, impervious surface area, storm drain density, watershed characteristics, and water quality metrics.</p>
    </div>

    <div>
        <h3>What is an impervious surface?</h3>
        <p>Impervious surfaces are man-made structures like roads, parking lots, and rooftops that prevent rainwater from soaking into the ground. Instead, water runs off these surfaces, picking up pollutants and increasing the volume and speed of runoff entering nearby streams. This can lead to erosion, habitat degradation, and increased pollution in salmon habitats.</p>
    </div>

    <div>
        <h3>What are storm discharge drains?</h3>
        <p>Storm dischargedrains are part of the urban drainage system that collects and channels surface water runoff from streets, parking lots, and other impervious surfaces to nearby streams or rivers. When these drains are not properly managed, they can carry pollutants directly into salmon habitats.</p>
    </div>

    <div>
        <h3>What is a watershed?</h3>
        <p>A watershed is an area of land that drains to a common water body, such as a stream or river. Watersheds are important in salmon habitat because they define the boundaries of the drainage area that contributes water and pollutants to a stream.</p>
    </div>

    <div>
        <h3>What is an impervious surface?</h3>
        <p>Impervious surfaces are man-made structures like roads, parking lots, and rooftops that prevent rainwater from soaking into the ground. Instead, water runs off these surfaces, picking up pollutants and increasing the volume and speed of runoff entering nearby streams. This can lead to erosion, habitat degradation, and increased pollution in salmon habitats.</p>
    </div>

    <div>
        <h3>How do heavy traffic roadways affect salmon habitats?</h3>
        <p>Heavy traffic roadways contribute to salmon habitat degradation through increased impervious surfaces, which lead to higher volumes of runoff and pollutants entering nearby streams. The runoff carries oil, heavy metals, and other contaminants that can be toxic to salmon and their spawning grounds.</p>
    </div>

    <div>
        <h3>How does rainfall affect salmon habitats?</h3>
        <p>Heavy rainfall can increase the volume and speed of runoff entering streams, carrying pollutants and sediments that can degrade salmon habitats. Excessive runoff can cause erosion, alter stream flow patterns, and introduce harmful substances that are toxic to salmon and their spawning grounds.</p>
    </div>

    <div>
        <h3>How does water quality affect salmon habitats?</h3>
        <p>Water quality is crucial for salmon survival. Pollutants such as heavy metals, pesticides, and excess nutrients can accumulate in streams and rivers, leading to habitat degradation. Poor water quality can reduce oxygen levels, increase toxicity, and disrupt the food chain that salmon depend on.</p>
    </div>

{% endblock %}
